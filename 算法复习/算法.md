算法的五个性质
有穷性；
特殊性
可行性
输入为零到多个输入
输出为1到多个输出



在经历了多重循环后依旧保持正确的性质为循环不变性

分治的基本性质
分：将原问题分为多个独立的子问题
治：递归的求解这些子问题，若规模可以更小就更小
合：合并子问题的求解的结果

若f(n)更大的时候，并且满足正则性条件，则可以使用。

期望时间是针对于随机算法，输入固定


动态规划的特点
最优子问题
这个问题的最优解包含其子问题的最优解
无后效性：当求解出一个子问题后这个子问题的值不会随着算法的进行而发生改变
重叠子问题：


贪心的思想：
由局部最优解推导出全局最优解，并且不会改变之前对于这个解的求解。

**14) 最优子结构与无后效性**

- **最优子结构 (Optimal Substructure)：** 问题的最优解包含其子问题的最优解。（具体证明方法参考我之前发的“剪切-粘贴”法）。
    
- **无后效性 (No-aftereffect)：** “未来与过去无关”。一旦某个状态确定了，它之后的演变只取决于该状态本身，而与如何到达该状态的路径无关


### **模块一：动态规划 (Dynamic Programming, DP)**

**(Q13 - Q17)**

- **13) 最优化问题 (Optimization Problem) 是什么？**
    
    - 指在众多满足约束条件的“可行解”中，寻找一个使目标函数值达到最大或最小的“最优解”的问题。
        
- **14) 最优子结构与无后效性**
    
    - **最优子结构 (Optimal Substructure)：** 问题的最优解包含其子问题的最优解。（具体证明方法参考我之前发的“剪切-粘贴”法）。
        
    - **无后效性 (No-aftereffect)：** “未来与过去无关”。一旦某个状态确定了，它之后的演变只取决于该状态本身，而与如何到达该状态的路径无关。
        
- **15) 状态转移方程 (Recurrence Relation)**
    
    - 这是DP的核心。它是一个数学公式，描述了如何利用较小规模子问题的解（子状态）来计算当前问题的解（当前状态）。例如背包问题：$dp[i][j] = \max(dp[i-1][j], dp[i-1][j-w] + v)$。
        
- **16) 子问题图 (Subproblem Graph)**
    
    - **画法：** 每一个节点代表一个子问题。如果解决子问题 $u$ 需要用到子问题 $v$ 的结果，则画一条有向边 $u \to v$（或反之，视定义方向而定）。
        
    - **性质：** 它是一个**有向无环图 (DAG)**。自底向上求解就是按拓扑逆序遍历；记忆化搜索就是按DFS遍历。
        
- **17) 动态规划带来的性能改进**
    
    - 通过**记忆化 (Memoization)** 或 **制表 (Tabulation)**，避免了重复计算重叠子问题。将朴素递归的**指数级时间**（如 $O(2^n)$）降低到了**多项式时间**（如 $O(n^2)$）。
        

---

### **模块二：贪心算法 (Greedy Algorithms)**

**(Q18 - Q21)**

- **18) 基本思想与贪心选择性质**
    
    - **思想：** 总是做出在当前看来最好的选择（局部最优），希望导致全局最优。
        
    - **贪心选择性质 (Greedy Choice Property)：** 全局最优解可以通过一系列局部最优的选择来达到。即不需要“回溯”或考虑所有情况，选了就不后悔。
        
- **19) 动态规划 vs. 贪心**
    
    - **相同点：** 都要求具备**最优子结构**。
        
    - **不同点：**
        
        - **DP：** 解决**重叠子问题**。通常是自底向上，每一步选择依赖于子问题的解（先解决子问题，再做选择）。
            
        - **贪心：** 自顶向下。每一步直接做当前最好的选择，**不依赖于**子问题的解（先做选择，再解决剩下的子问题）。
            
- **20) 最小生成树 (MST) 的相关概念**
    
    - **切割 (Cut)：** 将图的顶点集 $V$ 分为两个互不相交的集合 $(S, V-S)$。
        
    - **横跨切割 (Cross)：** 一条边的两个端点分别在 $S$ 和 $V-S$ 中。
        
    - **轻量级边 (Light Edge)：** 横跨某个切割的所有边中，权重最小的那条边。
        
    - **安全边 (Safe Edge)：** 添加到当前子集后，仍能保证该子集是某棵最小生成树的一部分的边。
        
- **21) Kruskal vs. Prim**
    
    - **Kruskal：** **以边为核心**。按权重排序边，用并查集 (Union-Find) 避免环。适合稀疏图。
        
    - **Prim：** **以点为核心**。类似Dijkstra，每次找离当前生成树最近的节点。适合稠密图。
        

---

### **模块三：图算法与最短路径**

**(Q22 - Q28)**

- **22) 松弛操作 (Relaxation)**
    
    - 对于边 $(u, v)$，检查是否可以通过 $u$ 找到一条到 $v$ 的更短路径。
        
    - 如果 $d[v] > d[u] + w(u, v)$，则更新 $d[v] = d[u] + w(u, v)$ 并更新前驱。
        
- **23) 最短路性质**
    
    - **三角不等式：** $\delta(s, v) \le \delta(s, u) + w(u, v)$。
        
    - **上界性质：** $d[v] \ge \delta(s, v)$，且一旦 $d[v]$ 达到 $\delta(s, v)$ 就不再改变。
        
- **24) Dijkstra 与负权边**
    
    - **异常原因：** Dijkstra 基于贪心策略，假设“取出的节点已经是最终最短路”。如果有负权边，可能通过后续节点绕回来使得之前的路径变短，破坏了贪心假设。
        
- **25) Bellman-Ford 与负权回路**
    
    - **检测方法：** 对所有边进行 $V-1$ 轮松弛后，再进行第 $V$ 轮松弛。如果第 $V$ 轮还能更新某个节点的距离，说明图中存在负权回路。
        
- **26) Johnson 算法**
    
    - **思想：** 用于全源最短路径。通过引入“势能函数” $h(v)$ 对边权进行**重新赋权 (Reweighting)**，将所有负权边变为非负边（且保持最短路性质不变），然后对每个节点跑 Dijkstra。
        
- **27) BFS, DFS, D-Search**
    
    - **BFS：** 广度优先，用队列，层级遍历，用于无权图最短路。
        
    - **DFS：** 深度优先，用栈（或递归），用于拓扑排序、连通性。
        
    - **D-Search (General Search)：** 通常指通用的图搜索框架，通过替换数据结构（栈、队列、优先队列）来实现 DFS、BFS 或 Best-First Search。
        
- **28) 生成树类型**
    
    - **BFS生成树：** 树高较矮，呈现放射状。
        
    - **DFS生成树：** 树高很高，呈现长链状。
        

---

### **模块四：搜索策略 (回溯与分支限界)**

**(Q29 - Q33)**

- **29) 回溯法 (Backtracking) vs. 分支-限界法 (Branch & Bound)**
    
    - **回溯法：** **深度优先** (DFS) 搜索解空间。通常用于找**所有解**。
        
    - **分支-限界法：** 通常用 **广度优先** 或 **最小耗费优先** 搜索。利用**界限函数**剪枝。通常用于找**最优解**。
        
    - **界限函数 (Bounding Function)：** 用于估算当前节点子树可能产生的最优值。如果估算值比当前找到的最优解还差，就剪掉这棵子树（剪枝）。
        
- **30) 空间概念**
    
    - **状态空间 (State Space)：** 所有可能的问题状态构成的集合。
        
    - **解空间树：** 将搜索过程抽象为一棵树。
        
- **32) 结点的成本函数**
    
    - $c(x)$：到达目标节点的真实成本。
        
    - $\hat{c}(x) = f(x) = g(x) + h(x)$：**估价函数**。
        
        - $g(x)$：从起点到当前点 $x$ 的实际代价。
            
        - $h(x)$：从 $x$ 到终点的**启发式估计代价**。
            
    - **影响：** $h(x)$ 越接近真实值，搜索效率越高（A*算法）。若 $h(x)=0$ 退化为 Dijkstra/BFS。
        

---

### **模块五：流网络**

**(Q34 - Q36)**

- **34) 流网络与最大流**
    
    - **流网络：** 一个有向图，每条边有容量 $c(u,v)$，有源点 $s$ 和汇点 $t$。
        
    - **最大流：** 从 $s$ 到 $t$ 传输的物质总量的最大值。满足**容量限制**和**流量守恒**。
        
- **35) Ford-Fulkerson 方法**
    
    - **核心：** 只要残存网络 (Residual Network) 中存在增广路径 (Augmenting Path)，就沿着路径增加流。
        
    - **最大流最小切割定理：** 一个网络的最大流值等于其最小切割的容量。
        
- **36) Edmonds-Karp 算法**
    
    - 是 Ford-Fulkerson 的一个实现。它使用 **BFS** 来寻找增广路径（即找跳数最少的路径）。时间复杂度为 $O(VE^2)$。
        

---

### **模块六：计算复杂性 (P vs NP)**

**(Q37 - 红色字体一般性了解)**

- **P类 (Polynomial)：** 能在多项式时间内**解决**的问题（易解）。
    
- **NP类 (Non-deterministic Polynomial)：** 能在多项式时间内**验证**一个解的问题（易验证）。
    
- **NPC (NP-Complete)：** NP 中最难的问题。如果解决了任何一个 NPC 问题（用多项式时间），那么所有 NP 问题都能解决（即 $P=NP$）。
    
    - 例子：SAT问题（可满足性问题）、哈密顿回路、旅行商问题(TSP)的判定版本。
        
- **归约 (Reduction)：** 将问题 A 转化为问题 B。如果 A 能转化为 B，说明 B 至少和 A 一样难。
    
- **证明 NPC 的方法：**


Knowing that i was goning to be better ,
And looking forward to a time that i would feel good again .
Helped me to keep moving forward 
And sometimes i had to be brave 
And it wasn't always easy
Sometimes i faltered 
i had bad days  
But i realize being brave isn't to be easy ,
As for me , i feel it is the key way to keep  moving forward.