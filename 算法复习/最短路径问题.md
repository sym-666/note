首先最短路径问题具有最优子结构性

负权重会带来一个问题就是通过转圈会使得最短路径无定义



对于图是初始化操作：
init 操作：
for each vertex v属于G.V 
	v.d = inf
	v.pai = NIL 
s.d = 0 ;

松弛操作：
//w是一个邻接图
relax(u,v,w)
 if (v.d>u.d+w(u,v))
	 v.d= u.d+w(u,v)
	 v.pai = u 

### 三角不等式的性质
![[Pasted image 20260106181559.png]]



### Bellman-Ford算法

Bellman-ford算法
	for int i =1 to i = V - 1 
		for each edge(u,v)
			 relax(u,v,w)
	for each edge(u,v)
		if u.d+w(u,v)< v.d
			return Fasle
	return True

对于每一个的E都执行了松弛操作V-1 遍谷运行时间是O（VE）

### Dijkstra 算法

DIJKSTAR（G，w , s）
	init (G,s)
![[QQ_1767704430902.png]]
DJ算法的伪代码如上
DJ是一个贪心算法，每个节点有且只有一个机会被提取出来。


### 差分约束系统

![[Pasted image 20260106203356.png]]

对于一个差分约束系统使用图来表示一个表达式
如V1-V2 <= 2,使用一个由V2 指向 V1 的权为2的箭头来表示

差分约束系统里面不能有负值环路，因为如果有环路的话会出现0< 负值

使用差分限制系统可以求出一组解

![[QQ_1767704366242.png]]

### 无源最短路问题

####  求法一：使用单源最短路问题推导
![[QQ_1767704566570.png]]
由上面可以看出当含有负节点的时候会出现V4 的复杂度。
这里可以找到更好的算法Floyd算法。
#### Floyd 算法
这是一个动态规划的算法
![[Pasted image 20260106210707.png]]

状态转移方程：
![[QQ_1767704867839.png]]
对于一个路径要么经过一个中间节点，要么不经过中间节点，对于如果经过中间节点会使得路径更优的话则更新路径，设d(k)为经过前k 个中心节点的最优的成本路径， 则可以通过检测每个路径是否可以通过插入中心节点k来使得路径最优使得递归到d(k+1)。
反复就可以求出最优的递归的方法了。 

伪代码如下：
![[QQ_1767705252126.png]]

johnson算法求最短路

##### 重新赋值最短路
利用三角不等式性质：对于最短路，必然满足 $h(v) \le h(u) + w(u, v)$，即 $w(u, v) + h(u) - h(v) \ge 0$。
我们构造新边权 $\hat{w}(u, v)$：

$$\hat{w}(u, v) = w(u, v) + h(u) - h(v)$$


##### 还原真实距离

我们在新图上算出的距离并不是原图的真实距离，需要还原。

还原公式为：

$$D_{old}(s, t) = D_{new}(s, t) - h(s) + h(t)$$